use std::borrow::Cow;

use rolldown_plugin::{HookLoadReturn, HookUsage, Plugin};

// Include the embedded helpers generated by build.rs
mod embedded_helpers;
use embedded_helpers::{get_helper_content, is_runtime_helper};

/// Plugin for handling @oxc-project/runtime helpers
/// This plugin embeds all ESM helpers from @oxc-project/runtime directly
/// to support browser environments where module resolution is not available
#[derive(Debug)]
pub struct OxcRuntimePlugin;

impl Plugin for OxcRuntimePlugin {
  fn name(&self) -> Cow<'static, str> {
    Cow::Borrowed("builtin:oxc-runtime")
  }

  fn register_hook_usage(&self) -> HookUsage {
    HookUsage::ResolveId | HookUsage::Load
  }

  async fn resolve_id(
    &self,
    _ctx: &rolldown_plugin::PluginContext,
    args: &rolldown_plugin::HookResolveIdArgs<'_>,
  ) -> rolldown_plugin::HookResolveIdReturn {
    if is_runtime_helper(args.specifier) {
      // Create virtual module ID with \0 prefix and .js suffix
      let virtual_id = if args.specifier.ends_with(".js") {
        format!("\0{}", args.specifier)
      } else {
        format!("\0{}.js", args.specifier)
      };
      return Ok(Some(rolldown_plugin::HookResolveIdOutput {
        id: virtual_id.into(),
        ..Default::default()
      }));
    }

    // Handle relative imports within the helpers, e.g., "./typeof.js"
    Ok(args.importer.and_then(|importer| {
      // Check if importer is a virtual module (starts with \0)
      let importer = importer.strip_prefix('\0')?;
      if !is_runtime_helper(importer) || !args.specifier.starts_with("./") {
        return None;
      }

      // For "@oxc-project/runtime/helpers/xxx", we just need to append the relative import
      // e.g., "@oxc-project/runtime/helpers/applyDecs" + "./typeof.js"
      //    -> "@oxc-project/runtime/helpers/typeof.js"
      let base_path = importer.rfind('/').map(|pos| &importer[..=pos])?;

      // For "./typeof.js", we need to convert it to "typeof"
      let helper_name = args.specifier[2..].trim_start_matches("./");

      let mut full_path = String::with_capacity(base_path.len() + helper_name.len() + 1);
      full_path.push('\0');
      full_path.push_str(base_path);
      full_path.push_str(helper_name);

      Some(rolldown_plugin::HookResolveIdOutput { id: full_path.into(), ..Default::default() })
    }))
  }

  fn resolve_id_meta(&self) -> Option<rolldown_plugin::PluginHookMeta> {
    Some(rolldown_plugin::PluginHookMeta { order: Some(rolldown_plugin::PluginOrder::Pre) })
  }

  async fn load(
    &self,
    _ctx: &rolldown_plugin::PluginContext,
    args: &rolldown_plugin::HookLoadArgs<'_>,
  ) -> HookLoadReturn {
    Ok(args.id.strip_prefix('\0').and_then(|id| {
      get_helper_content(id)
        .map(|code| rolldown_plugin::HookLoadOutput { code, ..Default::default() })
    }))
  }

  fn load_meta(&self) -> Option<rolldown_plugin::PluginHookMeta> {
    Some(rolldown_plugin::PluginHookMeta { order: Some(rolldown_plugin::PluginOrder::Pre) })
  }
}
