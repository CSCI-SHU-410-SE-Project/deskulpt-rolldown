use std::collections::BTreeMap;
use std::env;
use std::fs;
use std::io::Write as _;
use std::path::PathBuf;

use oxc_resolver::ResolveOptions;

fn main() {
  println!("cargo:rerun-if-changed=build.rs");

  // Get the workspace root directory
  let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
  let manifest_path = PathBuf::from(manifest_dir);
  let workspace_root = manifest_path.parent().unwrap().parent().unwrap().to_path_buf();

  // Use oxc_resolver to find @oxc-project/runtime
  let resolver = oxc_resolver::Resolver::new(ResolveOptions::default());

  let Ok(runtime_package) = resolver.resolve(&workspace_root, "@oxc-project/runtime/package.json")
  else {
    eprintln!("Warning: @oxc-project/runtime not found, skipping embedded helpers generation");
    return;
  };

  println!("cargo:rerun-if-changed={}", runtime_package.path().display());

  let version = runtime_package
    .package_json()
    .unwrap()
    .raw_json()
    .as_object()
    .and_then(|obj| obj.get("version"))
    .and_then(|v| v.as_str())
    .unwrap_or("unknown");

  let runtime_dir = runtime_package.path().parent().unwrap();
  let esm_helpers_dir = runtime_dir.join("src/helpers/esm");

  // Read all ESM helper files (use BTreeMap for deterministic ordering)
  let mut helpers = BTreeMap::new();
  if esm_helpers_dir.exists() {
    for entry in fs::read_dir(&esm_helpers_dir).unwrap() {
      let path = entry.unwrap().path();
      if path.extension().and_then(|s| s.to_str()) == Some("js") {
        let file_name = path.file_stem().unwrap().to_str().unwrap();
        let content = fs::read_to_string(&path).unwrap();
        helpers.insert(file_name.to_string(), content);
      }
    }
  }

  // Generate code to src/embedded_helpers.rs
  let src_dir = manifest_path.join("src");
  let dest_path = src_dir.join("embedded_helpers.rs");

  let mut file = fs::File::create(&dest_path).unwrap();

  // Write file header with version info
  writeln!(
    &mut file,
    "// Auto-generated by build.rs - DO NOT EDIT MANUALLY\n\
     // This file contains embedded @oxc-project/runtime ESM helpers\n\
     // @oxc-project/runtime version: {}\n",
    version
  )
  .unwrap();

  // Write the static helper map using phf with ArcStr values
  writeln!(
    &mut file,
    r#"use arcstr::ArcStr;
use phf::{{Map, phf_map}};

pub const RUNTIME_HELPER_PREFIX: &str = "@oxc-project+runtime@{}/helpers/";
pub const RUNTIME_HELPER_UNVERSIONED_PREFIX: &str = "@oxc-project/runtime/helpers/";

/// Map of all ESM helpers from @oxc-project/runtime/src/helpers/esm/
pub static ESM_HELPERS: Map<&'static str, ArcStr> = phf_map! {{"#,
    version,
  )
  .unwrap();

  for (helper_name, content) in &helpers {
    // Calculate hash count for raw string literal
    let hash_count = calculate_hash_count(content);
    let hashes = "#".repeat(hash_count);

    writeln!(
      &mut file,
      "  \"{}\" => arcstr::literal!(r{hashes}\"{}\"{hashes}),",
      helper_name, content
    )
    .unwrap();
  }

  writeln!(&mut file, "}};").unwrap();
  writeln!(&mut file).unwrap();

  // Write helper functions
  writeln!(
    &mut file,
    r#"/// Get the content of a helper by its specifier
pub fn get_helper_content(specifier: &str) -> Option<ArcStr> {{
  let helper_name = specifier.strip_prefix(RUNTIME_HELPER_PREFIX)?;
  ESM_HELPERS.get(helper_name.strip_suffix(".js").unwrap_or(helper_name)).cloned()
}}

/// Check if a specifier is an OXC runtime helper
pub fn is_runtime_helper(specifier: &str) -> bool {{
  specifier.starts_with(RUNTIME_HELPER_UNVERSIONED_PREFIX)
}}

/// Check if a specifier is a virtual runtime helper (with \0 prefix)
pub fn is_virtual_runtime_helper(specifier: &str) -> bool {{
  specifier.starts_with(RUNTIME_HELPER_PREFIX)
}}"#
  )
  .unwrap();

  println!(
    "Generated {} ESM helpers from @oxc-project/runtime v{} to src/embedded_helpers.rs",
    helpers.len(),
    version
  );
}

/// Calculate the number of # needed for raw string literal
fn calculate_hash_count(content: &str) -> usize {
  let mut count = 0;
  let mut chars = content.chars().peekable();

  while let Some(ch) = chars.next() {
    if ch == '"' {
      let mut hash_seq = 0;
      while chars.peek() == Some(&'#') {
        chars.next();
        hash_seq += 1;
      }
      count = count.max(hash_seq);
    }
  }

  count + 1 // Add one more to be safe
}
